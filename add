#!/usr/bin/perl -w
use strict;
use POSIX qw(strftime);

sub dirname($)
{
    my $filename = shift @_;
    $filename =~ m{(.*)/([^/]+)}  &&  return $1;
    return ".";
}

sub neat_times() {
    my ($user,$system,$cuser,$csystem) = times;
    my $wall = time - $^T;
    return sprintf("Times: wallclock=%ds user+sys=%.2fs sys=%.2fs\n",
		   $wall, $cuser+$csystem, $csystem);
}

my $want_quiet = (@ARGV && $ARGV[0] eq '-Q' && shift @ARGV);

if (@ARGV < 1) {
    print STDERR "Usage: $0 [-Q] <section> [commandline...]\n";
    print STDERR "  Copies stdin or command output to a new logfile in <section>.\n";
    exit 1;
}

my $homedir = dirname($0);
die("Can't find home directory '$homedir'\n") unless -d "$homedir/.";

die("Can't find 'data' directory!") unless -d "$homedir/data/.";

my $section = shift @ARGV;

die("No such section '$homedir/data/$section'\n")
  unless -d "$homedir/data/$section";

my $date = strftime("%Y%m%d-%H%M%S", localtime()) . "." . int(rand(100000));
my $tmpfile = "$homedir/data/$section/.tmp.$date";
my $realfile = "$homedir/data/$section/$date";

open my $fh, ">$tmpfile" or die("Create $tmpfile: $!\n");

sub print_log($) {
    print $fh @_
      or die "Writing $tmpfile: $!";
}

my $host = `hostname`;
$host =~ s/\s+//g;

my $user = getpwuid($>);

print_log("Starting: $date on host=$host user=$user\n");
print_log("-Q: no news is good news\n") if $want_quiet;
if (@ARGV) {
    print_log("Command: " . join(' ', @ARGV) . "\n");
}
print_log("\n");

my $any = 0;
my $ret = -1;
if (@ARGV) {
    my $pid = open(my $infh, "-|");
    if (!defined $pid) {
	print_log("fork failed: $!\n");
	$any++;
    } elsif ($pid) {
	# main process
	while (<$infh>) {
	    if (/^EXIT CODE: (\d+)/) {
		$ret = $1;
		$any--; # bodge: compensate for "\n" before "EXIT CODE"
	    } else {
		$any++;
	    }
	    print_log($_);
	}
	close $infh;
	print_log(neat_times());
    } else {
	# subprocess
	open STDERR, ">&STDOUT";
	my $ret = system(@ARGV);
	if ($ret & 127) {
	    print "\nSIGNAL: $ret\n";
	    $ret = 127;
	} else {
	    $ret >>= 8;
	}
	print "\nEXIT CODE: $ret\n"; # nb. matching $any-- above
	exit($ret);
    }
} else {
    while (<STDIN>) {
	print_log($_);
	$any++;
    }
}

print_log("No messages.\n") unless $any;
close $fh;

my $ok;
if ($want_quiet) {
    # "silence is golden" semantic
    $ok = (!$any && $ret == 0);
} else {
    # Assume zero-length output means success, else failure.
    # (same logic as cron uses)
    $ok = (!$any || $ret==0);
}
rename($tmpfile, $realfile.($ok ? '.ok' : ''))
  or die "Rename $tmpfile: $!";

system("touch", "$homedir/data/$section/.stamp");

# we exit with code zero even if the subprogram failed, because we
# don't want cron to *also* try to log stuff.
exit 0;
